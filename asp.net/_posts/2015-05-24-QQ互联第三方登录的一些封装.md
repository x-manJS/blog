---
layout: post 
title:  QQ互联第三方登录的一些封装
tags: QQ第三放登陆
---


昨天用js-sdk实现了用户登陆，但觉得用户体验非常差，所以今天把QQ互联登陆在C# MVC的基础上进行写了控制器和业务。

代码下载可：[http://pan.baidu.com/s/1dDdFNv7](http://pan.baidu.com/s/1dDdFNv7)


控制器：

	public class QQController : Controller
    {

        private QQBusiness _qqBusiness;
        public QQController()
        {
            _qqBusiness = new QQBusiness();
        }

        /// <summary>
        /// 跳转到登陆页面
        /// </summary>
        public ActionResult Link()
        {
            string loginUrl = _qqBusiness.BuildAuthLink();
            return Redirect(loginUrl);
        }

        /// <summary>
        /// 授权回调后的页面
        /// </summary>
        /// <returns></returns>
        public string Callback(string state, string code)
        {
            CallbackModel qqInfo =  _qqBusiness.CallBack(state, code);
            return null;
        }
    }

这里有两个控制器。

访问`http://<host>/qq/link` 实现跳转到QQ授权的页面  
`http://<host>/qq/link`则是QQ用户授权后回调路径。这里面进行业务逻辑处理。注意的是，在QQ互联的应用里的回调地址应该填`http://<host>/qq/link`，否则会报错。



业务逻辑类：

	 public class QQBusiness
	    {
	        private readonly string client_id = "100630773"; // appID
	        private readonly string client_secret = "a27504dbdef072dfb928aabe15efd102"; // appKey
	        private readonly string redirect_uri = "http://wyfans.com/qq/callback"; // 必须和QQ互联里的应用里填写的回到函数一致
	
	        private string _loginUrl = "https://graph.qq.com/oauth2.0/authorize?response_type=code&client_id={0}&state={1}&redirect_uri={2}&scope=get_user_info,get_info,get_other_info,permission_weibo";
	
	        private string _code = string.Empty;
	        private string _state = string.Empty;
	
	        /// <summary>
	        /// 更具code查询到的用户的信息
	        /// </summary>
	        private string _infoQueryByCode;
	        private string _accessToken;
	        private string _openId;
	
	        /// <summary>
	        /// 生成跳转到QQ第三方登陆的链接
	        /// </summary>
	        /// <returns></returns>
	        public string BuildAuthLink()
	        {
	            string state = Guid.NewGuid().ToString().Replace("-", "");
	            HttpContext.Current.Session["state"] = state;  // state，回调后有用
	            string encodeUrl = HttpUtility.UrlEncode(redirect_uri, Encoding.Default);
	            string loginUrl = string.Format(_loginUrl, client_id, client_secret, encodeUrl);
	
	            return loginUrl;
	        }
	
	        /// <summary>
	        /// 回调函数
	        /// </summary>
	        /// <param name="state"></param>
	        /// <param name="code"></param>
	        /// <returns></returns>
	        public CallbackModel CallBack(string state, string code)
	        {
	            _code = code;
	            _state = state;
	
	            CallbackModel result = new CallbackModel();
	
	            if (CheckState())
	            {
	                result.OpenId = GetUserOpenId();
	                result.ClientId = client_id;
	                result.State = _state;
	                result.qqUserInfo = GetUserInfo();
	
	                return result;
	            }
	            throw new Exception("非法第三方登陆");
	        }
	
	        /// <summary>
	        /// 判断授权返回的state值是不是授权之前设置的
	        /// </summary>
	        /// <param name="state"></param>
	        /// <returns></returns>
	        private bool CheckState()
	        {
	            if (HttpContext.Current.Session["state"] == null || HttpContext.Current.Session["state"].ToString() == "")
	            {
	                throw new Exception("亲，QQ登陆失败，请重新登陆");
	            }
	            return true;
	        }
	
	        /// <summary>
	        /// 通过Access Token来获取用户的OpenID
	        /// </summary>
	        private string GetUserOpenId()
	        {
	            if (_openId == null)
	            {
	                string access_token = GetAccessToken();
	
	                string send_url = "https://graph.qq.com/oauth2.0/me?access_token=" + access_token;
	                string result = HttpMethods.HttpGet(send_url);
	
	                if (result.Contains("error"))
	                {
	                    throw new Exception("QQ第三方接口故障，请重新登陆");
	                }
	
	                int str_start = result.IndexOf('(') + 1;
	                int str_last = result.LastIndexOf(')') - 1;
	
	                result = result.Substring(str_start, (str_last - str_start));//取得JSON字符串
	
	                OpenIdClientIdModel openIdModel = FastJsonSerializer.DeSerialize<OpenIdClientIdModel>(result);
	                _openId = openIdModel.openid;
	            }
	
	            return _openId;
	        }
	
	        /// <summary>
	        /// 获取access_token
	        /// </summary>
	        /// <param name="state"></param>
	        /// <param name="code"></param>
	        /// <returns></returns>
	        private string GetAccessToken()
	        {
	            if (_accessToken == null)
	            {
	                string result = GetInfoByCode();
	
	                string[] parm = result.Split('&');
	                _accessToken = parm[0].Split('=')[1];
	            }
	
	            return _accessToken;
	        }
	
	        /// <summary>
	        /// 根据code获取授权信息
	        /// </summary>
	        /// <returns></returns>
	        private string GetInfoByCode()
	        {
	            if (_infoQueryByCode == null)
	            {
	                string sendUrl = "https://graph.qq.com/oauth2.0/token?grant_type=authorization_code&client_id={1}&client_secret={2}&code={3}&state={4}&redirect_uri={5}";
	                sendUrl = string.Format(sendUrl, "", client_id, client_secret, _code, _state, redirect_uri);
	
	                _infoQueryByCode = HttpMethods.HttpGet(sendUrl);
	                if (_infoQueryByCode.Contains("error"))
	                {
	                    throw new Exception("QQ第三方接口故障，请重新登陆");
	                }
	            }
	
	            return _infoQueryByCode;
	        }
	
	        /// <summary>
	        /// 通过Access Token和OpenID来使用get_user_info方法获取用户资料(需要有get_user_user权限，QQ互联那边申请)
	        /// </summary>
	        private QQUserInfo GetUserInfo()
	        {
	
	            string accessToken = GetAccessToken();
	            string openId = GetUserOpenId();
	
	            string sendUrl = "https://graph.qq.com/user/get_user_info?access_token=" + accessToken + "&oauth_consumer_key=" + client_id + "&openid=" + openId;
	
	            string rezult = HttpMethods.HttpGet(sendUrl);
	            QQUserInfo qquserInfo = FastJsonSerializer.DeSerialize<QQUserInfo>(rezult);
	            return qquserInfo;
	        }



以上的`client_id`和`client_secret`需要改为你的应用的信息。

业务步骤基本上为：  

1.通过回调的code和state查询授权信息  
2.在授权信息中获取AccessToken  
3.用AccessToken获取OpenID，用来标示唯一用户的变量。  
4.用 AccessToken和OpenID调用get_user_info接口获取用户信息。这个接口需要在QQ互联申请相应的接口。


最后可以据需在callbakc中处理你的业务逻辑。